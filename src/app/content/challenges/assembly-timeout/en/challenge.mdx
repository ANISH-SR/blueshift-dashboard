import { ArticleSection } from "../../../../../components/ArticleSection/ArticleSection";

# Assembly Timeout

// Missing banner

In this unit we'll use sBPF Assembly to create a time-based validation instruction that enforces slot-height deadlines.

By including this instruction in your transaction, you create a fail-safe mechanism that prevents execution after a specified blockchain time, protecting against delayed transaction execution or stale instruction replays.

Several properties make timeout checks ideal for assembly:
- Single, constrained use case
- Efficient leverage of system variables
- No complex account validation required
- Only improves transaction safety

If you're unfamiliar with assembly programming, follow the [introduction to Assembly course](en/courses/introduction-to-assembly)

<ArticleSection name="Program Design" id="program-design" level="h2" />

Our program implements a crucial temporal operation: validating that the current blockchain slot height hasn't exceeded a predetermined deadline. This pattern is essential for time-sensitive DeFi operations—from preventing stale arbitrage attempts to enforcing auction deadlines.

The program expects:
- An 8-byte maximum slot height in the instruction data.
- Access to Solana's Clock sysvar through `sol_get_clock_sysvar`.
- Returns success if current slot ≤ max slot, error otherwise.

<ArticleSection name="Memory Offsets" id="memory-offsets" level="h2" />

sBPF programs receive account data as contiguous memory regions. These constants define byte offsets within that memory.

Since our program accepts zero accounts, we can calculate where `MAX_SLOT_HEIGHT` (passed as instruction data) will be located. We'll also store the `Clock` sysvar data on the stack, for this reason the `CURRENT_SLOT_HEIGHT` will be negative.

These constants define our memory layout:   

```sbpf
.equ NUM_ACCOUNTS, 0x0000
.equ MAX_SLOT_HEIGHT, 0x0010
.equ CURRENT_SLOT_HEIGHT, -0x0028
```

- `NUM_ACCOUNTS` (0x0000): Points to the account count in the instruction data header for validation
- `MAX_SLOT_HEIGHT` (0x0010): Locates the 8-byte deadline slot height within the instruction data payload
- `CURRENT_SLOT_HEIGHT` (-0x0028): Stack offset where the Clock sysvar's slot field will be stored. Since slot is the first field in the Clock structure, this offset points directly to it
> 
You can generate offsets using our tooling at [sbpf.xyz](https://sbpf.xyz)

Unlike high-level languages that abstract memory layout, assembly requires knowing exactly where every piece of data lives.

<ArticleSection name="Entrypoint and Initial Validation" id="entrypoint-and-validations" level="h2" />

```sbpf
.globl entrypoint
entrypoint:
  ldxdw r0, [r1+NUM_ACCOUNTS]       // Veto if any accounts are included
  ldxdw r2, [r1+MAX_SLOT_HEIGHT]    // Store target slot height
```

Every sBPF program starts at a global `.entrypoint` symbol. The Solana runtime provides account and instruction data through register `r1`.

We validate that no accounts are passed by loading the account count into `r0`. Since `r0` is the register the VM reads on exit, any non-zero value automatically fails the program (exactly what we want if accounts are passed).

The second load retrieves our maximum allowed slot height from the instruction data, storing it in `r2` for later comparison.

<ArticleSection name="The Clock Sysvar" id="the-clock-sysvar" level="h2" />

```sbpf
mov64 r1, r10
add64 r1, CURRENT_SLOT_HEIGHT
call sol_get_clock_sysvar
ldxdw r1, [r1+0x0000]
```

The `sol_get_clock_sysvar` syscall writes current `Clock` data to `r1`. 

Since the Clock structure is 40 bytes (too large for registers that hold only 8 bytes each), we use the stack for fast, allocation-free storage with automatic cleanup.

Since `r10` is read-only, to operate on the stack we need to copy its memory address into a registrar: `mov64 r1, r10`

Then we add `CURRENT_SLOT_HEIGHT` (-0x0028) to `r1`. Since this constant is negative, it's actually subtraction: `r1 = r10 - 40 bytes`, allocating 40 bytes on the stack.

After calling the `sol_get_clock_sysvar` function, `r1` contains the memory address where Clock data was written, not the slot value itself. For this reason we proceed to load the actual slot value using `ldxdw r1, [r1+0x0000]`.

<ArticleSection name="Temporal Comparison Logic" id="temporal-comparison-logic" level="h2" />

```sbpf
jle r1, r2, end    // If current slot <= max slot, success
lddw r0, 1         // Otherwise, set error code
```

The core timeout logic uses a single conditional jump:
- Temporal validation: `jle` (jump if less or equal) compares current slot (`r1`) against our deadline (`r2`). If we're within the time window, jump to `exit`
- Timeout handling: If the deadline has passed, execution continues to load (`lddw`) error code 1 into return register `r0`

<ArticleSection name="Alternative Design" id="alternative-design" level="h2" />

For simpler implementation, you can pass the `Clock` sysvar account directly instead of using syscalls. This approach makes the instruction data a little bit larger but significantly reduce complexity.

```sbpf
.equ MAX_SLOT_HEIGHT, 0x2898
.equ CURRENT_SLOT_HEIGHT, 0x0060

.globl e
e:
  ldxdw r2, [r1+MAX_SLOT_HEIGHT]     // Store target slot height
  ldxdw r1, [r1+CURRENT_SLOT_HEIGHT] // Load current slot from Clock account
  jle r1, r2, end                    // If current slot <= max slot, success
  lddw r0, 1                         // Otherwise, set error code
end:
  exit
```

This approach requires passing `SysvarC1ock11111111111111111111111111` as an account, but eliminates stack management and having to call the syscall since the `Clock` account data is already deserialized and available at a known offset (`CURRENT_SLOT_HEIGHT`).

### Additional Checks 

To make this approach safe we would need to add some validation: 

```sbpf
// Check if account count is exactly 1
ldxb r2, [r1+0x0]                  // Load account count
jne r2, 1, error                   // If not 1 account, error

// Get pointer to first account key
mov r3, r1
add r3, ACCOUNT1_KEY               // r3 points to account key

// Validate Clock sysvar address using direct 64-bit comparisons
ldxdw r4, [r3+0x0]                 // Load first 8 bytes
jne r4, 0x06a7d51718c774c9, error  // Compare with constant

ldxdw r4, [r3+0x8]                 // Load second 8 bytes  
jne r4, 0x28566398691d5eb6, error  // Compare with constant

ldxdw r4, [r3+0x10]                // Load third 8 bytes
jne r4, 0x8b5eb8a39b4b6d5c, error  // Compare with constant

ldxdw r4, [r3+0x18]                // Load fourth 8 bytes
jne r4, 0x73555b2100000000, error  // Compare with constant
```

Here we check if we only have one account, to make sure that `.equ CURRENT_SLOT_HEIGHT, 0x0060` is at the right offset and we then check if the address is correct (.equ ACCOUNT1_KEY, 0x0010).

We can set errors like this:

```sbpf
error:
  lddw r0, 1                         // Set error code
  exit
```

<ArticleSection name="Conclusion" id="conclusion" level="h2" />

This compact program accomplishes temporal validation with minimal compute unit consumption.

The trade-off is understanding syscall interfaces, stack management, and the `Clock` sysvar's binary layout. But for performance-critical temporal validations, assembly provides unmatched efficiency.