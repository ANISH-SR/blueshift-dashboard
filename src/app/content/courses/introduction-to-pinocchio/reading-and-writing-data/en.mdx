import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../components/Codeblock/Codeblock";

# Reading and Writing Data

Pinocchio is designed for maximum performance, which often requires direct, low-level memory operations, such as pointer arithmetic and manual buffer manipulation.

To achieve this, we frequently use Rust’s unsafe features. In Rust, “unsafe” means the compiler cannot guarantee memory safety. However, unsafe code can still be correct and reliable if we rigorously uphold and document the assumptions that make it so. 

In Pinocchio, we can do this because we have precise control over how the compiler structure, serialize and pass the data into our programs.

For example, we might assume: “This buffer is always at least 32 bytes because it is constructed by X, so it is safe to read 32 bytes from it.”

Whenever we write or read data using unsafe code, we must consciously check and document these assumptions:
- The buffer size is always correct for the operation.
- Data is properly aligned in memory.
- There are no overlapping mutable references.
- All reads and writes stay strictly within bounds.

By making these assumptions explicit and verifying them, we can write highly optimized code that is also robust and maintainable; even when the Rust compiler cannot enforce safety for us.

<ArticleSection name="Reading Data" id="reading-data" level="h2" />

There are several ways to read data from a byte slice in an "unsafe" context, each with different trade-offs between safety and performance. Let’s look at the most common patterns:

Always start by checking that the buffer is at least as large as the data you want to read:

```rust
if data.len().le(size_of::<u64>()) {
    return Err(ProgramError::InvalidInstructionData);
}
```

for transmuting data instead, we need to make sure that the data lenght is exactly as we want:

```rust
if data.len().ne(&size_of::<u64>()) {
    return Err(ProgramError::InvalidInstructionData);
}
```

We can move to then parse each field individually:

```rust
pub struct DepositInstructionData {
    pub amount: u64,
}

impl<'a> TryFrom<&'a [u8]> for DepositInstructionData {
    type Error = ProgramError;

    fn try_from(data: &'a [u8]) -> Result<Self, Self::Error> {
        if data.len().ge(&size_of::<u64>()) {
            return Err(ProgramError::InvalidInstructionData);
        }

        let amount = u64::from_le_bytes(data.try_into().unwrap());

        Ok(Self { amount })
    }
}
```

> The data should be serialized as little-endian bytes, but it’s always a good idea to double-check using `u64::from_le_bytes`.

Or, for maximum performance, you can reinterpret a byte slice as a struct using `read_unaligned`. This only works if you guarantee the layout and size:

```rust
#[repr(C), packed]
pub struct DepositInstructionData {
    pub amount: u64,
}

impl<'a> TryFrom<&'a [u8]> for DepositInstructionData {
    type Error = ProgramError;

    fn try_from(data: &'a [u8]) -> Result<Self, Self::Error> {
        if data.len().ne(size_of::<u64>()) {
            return Err(ProgramError::InvalidInstructionData);
        }

        // SAFETY: We checked the length and the struct is repr(C, packed)
       Ok(unsafe { (data.as_ptr() as *const Self).read_unaligned() })
    }
}
```

> When using `read_unaligned`, it is critical that the struct uses `#[repr(C, packed)]` to guarantee the layout, and that the buffer is exactly the right size. Note: `read_unaligned` is safe for unaligned data.

### Undefined Behaviour

At first glance, using `read_unaligned()` and `core::mem::transmute()` may seem similar, but there is a crucial difference:
- `read_unaligned()`: Safe for unaligned data, as long as the layout matches (`#[repr(C, packed)]`). No undefined behavior from misalignment.
- `transmute()`: Unsafe for unaligned data, even if packed. You must ensure both layout and alignment. Using transmute on an unaligned pointer is undefined behavior.

The only way to guarantee that data is aligned is to create a struct with `#[repr(align(N))]`, but this only works if you control the allocation of the buffer. 

With a byte slice, you do not control the alignment. The only way to do is by allocating your own buffer (e.g., with `Box<[u8]>` or `Vec<u8>`) but this is not possible in `no_std` environments like Pinocchio, and is usually not worth the overhead compared to simply using `read_unaligned()`.

<ArticleSection name="Writing Data" id="writing-data" level="h2" />

Writing data follows the same principles as reading. So we'll focus more on showing you different patterns to write data into a struct.

Let's take the example of the `Config` struct  of our amm program: 

```rust
#[repr(C, packed)]
pub struct Config {
    pub state: u8,
    pub seed: u64,
    pub authority: Pubkey,
    pub mint_x: Pubkey, // Token X Mint
    pub mint_y: Pubkey, // Token Y Mint
    pub fee: u16,       // Swap fee in basis points
    pub config_bump: [u8; 1],
}
```

The safest approach is to serialize each field individually, ensuring correct byte order and avoiding alignment issues. This is especially useful for simple or variable-sized data.

```rust
fn write_config_to_slice(
    account_info: &AccountInfo,
    state: u8,
    seed: u64,
    authority: Pubkey,
    mint_x: Pubkey,
    mint_y: Pubkey,
    fee: u16,
    config_bump: [u8; 1],
) -> Result<(), ProgramError> {
    let data = account_info.try_borrow_mut_data()?;

    if data.len().ne(&Config::LEN) {
        return Err(ProgramError::InvalidAccountData);
    }

    data[0] = state;
    data[1..9].copy_from_slice(&seed.to_le_bytes());
    data[9..41].copy_from_slice(authority.as_ref());
    data[41..73].copy_from_slice(mint_x.as_ref());
    data[73..105].copy_from_slice(mint_y.as_ref());
    data[105..107].copy_from_slice(&fee.to_le_bytes());
    data[107] = config_bump[0];

    Ok(())
}
```

> Tip: Always double-check your offsets and lengths to avoid off-by-one errors. Or if you're feeling fancy create const with the offsets so it's easier to update if you decide to change the ordering of the fields.

Or for maximum performance and ergonomics, you can reinterpret the account’s data buffer as a struct and mutate its fields directly. Since we usually are already "loading" the account to check for ownership and discriminator, we can use the following pattern:

```rust
impl Config {
    #[inline(always)]
    pub fn load_mut(account_info: &AccountInfo) -> Result<&Self, ProgramError> {
        if account_info.owner().ne(&crate::ID) {
            return Err(ProgramError::InvalidAccountData);
        }

        let data = account_info.try_borrow_mut_data()?;

        if data.len().ne(&Config::LEN) {
            return Err(ProgramError::InvalidAccountData);
        }

        Ok(unsafe { &mut *(bytes.as_mut_ptr() as *mut Self) })
    }

    #[inline(always)]
    pub unsafe fn set_authority_unchecked(
        &mut self,
        authority: Pubkey,
    ) -> Result<(), ProgramError> {
        self.authority = authority;

        Ok(())
    }
}
```

And usage:

```rust
let config = Config::load_mut(&self.accounts.config)?;
unsafe { config.set_authority_unchecked(instruction_data.authority) }?;
```

> As noted previously, the struct must be `#[repr(C, packed)]` to ensure layout matches the buffer and the buffer must be exactly the right size.

<ArticleSection name="Dynamically Sized Data" id="dynamically-sized-data" level="h2" />

Whenever possible, avoid storing dynamically sized data directly in accounts. However, some use cases require it. 

> In Pinocchio, handling dynamic data is more challenging than in Anchor or standard Rust, primarily due to the `no_std` environment, which prevents us from using heap-allocated types like `Vec` or `String`.

If your account contains dynamic data, always place all statically sized fields at the beginning of your struct, and append the dynamic data at the end.

### Reading Dynamic Data

To avoid undefined behavior, always check that the account data buffer is at least as large as the statically sized portion. The dynamic section may be empty, so this check is essential.

This layout ensures that the offsets for fixed-size fields are always known, regardless of the dynamic data’s length.

There are two main scenarios when reading dynamically sized data:

- Single dynamic field at the end: You can easily determine the size and offset of the dynamic data at runtime like this:

```rust
const DYNAMIC_DATA_START_OFFSET: usize = size_of::<[u8; 32]>();

#[repr(C)]
pub struct DynamicallySizedAccount {
    pub sized_data: [u8; 32],
    // pub dynamic_data: &'info [u8], // Not part of the struct, but follows in the buffer
}

impl DynamicallySizedAccount {
    /// Returns the length of the dynamic data section.
    #[inline(always)]
    pub fn get_dynamic_data_len(data: &[u8]) -> Result<usize, ProgramError> {
        if data.len().le(&DYNAMIC_DATA_START_OFFSET) {
            return Err(ProgramError::InvalidAccountData);
        }

        Ok(data.len() - DYNAMIC_DATA_START_OFFSET)
    }

    /// Returns a slice of the dynamic data.
    #[inline(always)]
    pub fn read_dynamic_data(data: &[u8]) -> Result<&[u8], ProgramError> {
        if data.len().le(&DYNAMIC_DATA_START_OFFSET) {
            return Err(ProgramError::InvalidAccountData);
        }

        Ok(&data[DYNAMIC_DATA_START_OFFSET..])
    }
}
```

- Multiple dynamic field at the end: This scenario is more complex, since you need a way to determine the length of each dynamic field except the last. The most common approach is to prefix each dynamic field (except the last) with its length, so you can parse the buffer correctly.

Here’s a simple and robust pattern: store the length of the first dynamic field as a u8 (or u16, etc. if you need larger sizes) immediately after the statically sized data. The first dynamic field follows, and the second dynamic field occupies the remainder of the buffer.

```rust
const DYNAMIC_DATA_START_OFFSET: usize = size_of::<[u8; 32]>();
const MINIMUM_STRUCT_SIZE: usize = DYNAMIC_DATA_START_OFFSET + size_of::<u8>();

#[repr(C)]
pub struct DynamicallySizedAccount {
    pub sized_data: [u8; 32],
    // dynamic_data_1 and dynamic_data_2 follow in the buffer
}

impl DynamicallySizedAccount {
    /// Returns the length of the first dynamic data section.
    #[inline(always)]
    pub fn get_dynamic_data_1_len(data: &[u8]) -> Result<usize, ProgramError> {
        if data.len() < MINIMUM_STRUCT_SIZE {
            return Err(ProgramError::InvalidAccountData);
        }

        // The length is stored as a u8 immediately after the static data
        Ok(data[DYNAMIC_DATA_START_OFFSET] as usize)
    }

    /// Returns a slice of the first dynamic data section.
    #[inline(always)]
    pub fn read_dynamic_data_1(data: &[u8]) -> Result<&[u8], ProgramError> {
        let len = Self::get_dynamic_data_1_len(data)?;

        if data.len() < MINIMUM_STRUCT_SIZE + len {
            return Err(ProgramError::InvalidAccountData);
        }

        let offset = MINIMUM_STRUCT_SIZE;
        
        Ok(&data[offset..offset + len])
    }

    /// Returns a slice of the second dynamic data section (the remainder).
    #[inline(always)]
    pub fn read_dynamic_data_2(data: &[u8]) -> Result<&[u8], ProgramError> {
        let len = Self::get_dynamic_data_1_len(data)?;

        if data.len() < MINIMUM_STRUCT_SIZE + len {
            return Err(ProgramError::InvalidAccountData);
        }

        Ok(&data[MINIMUM_STRUCT_SIZE + len..])
    }
}
```

### Writing Dynamic Data

Writing dynamic data into an account buffer follows the same principles as reading: you must carefully lay out each field in the correct order and explicitly encode the lengths of dynamic fields so they can be parsed later.

This layout ensures that the offsets for fixed-size fields are always known, and dynamic fields can be efficiently written and read.

There are two main scenarios when writing dynamically sized data:

- Single dynamic field at the end: You can simply write the statically sized fields first, then the dynamic field using:

```rust
let buffer = core::slice::from_raw_parts_mut(
    data.as_mut_ptr().add(DYNAMIC_DATA_START_OFFSET),
    dynamic_data.len(),
);
buffer.copy_from_slice(dynamic_data);
```

- Multiple dynamic fields at the end: You need to prefix each dynamic field (except the last) with its length, so you can later determine where each field starts and ends during reading. Here’s how you can do it:

```rust
fn write_dynamically_sized_account(
    data: &mut [u8],
    sized_data: &[u8; 32],
    dynamic_data_1: &str,
    dynamic_data_2: &str,
) -> Result<(), ProgramError> {
    let d1 = dynamic_data_1.as_bytes();
    let d2 = dynamic_data_2.as_bytes();
    let total_len = MINIMUM_STRUCT_SIZE + d1.len() + d2.len();

    if data.len() != total_len {
        return Err(ProgramError::InvalidAccountData);
    }
    if d1.len() > u8::MAX as usize {
        return Err(ProgramError::InvalidInstructionData);
    }

    // Write statically sized data
    data[..DYNAMIC_DATA_START_OFFSET].copy_from_slice(sized_data);

    // Write length of first dynamic field
    let mut offset = DYNAMIC_DATA_START_OFFSET;
    data[offset] = d1.len() as u8;
    offset += 1;

    // Write first dynamic field
    unsafe {
        let dst = core::slice::from_raw_parts_mut(data.as_mut_ptr().add(offset), d1.len());
        dst.copy_from_slice(d1);
    }
    offset += d1.len();

    // Write second dynamic field
    unsafe {
        let dst = core::slice::from_raw_parts_mut(data.as_mut_ptr().add(offset), d2.len());
        dst.copy_from_slice(d2);
    }

    Ok(())
}
```

> Tip: Every time you update a dynamic field, if the size changes, you must resize the account. Here’s a general-purpose function for resizing an account:

```rust
pub fn resize_account(
    account: &AccountInfo,
    payer: &AccountInfo,
    new_size: usize,
    zero_out: bool,
) -> ProgramResult {
    // If the account is already the correct size, return early
    if new_size == account.data_len() {
        return Ok(());
    }

    // Calculate rent requirements
    let rent = Rent::get()?;
    let new_minimum_balance = rent.minimum_balance(new_size);

    // Adjust lamports to meet rent-exemption requirements
    match new_minimum_balance.cmp(&account.lamports()) {
        core::cmp::Ordering::Greater => {
            // Need more lamports for rent exemption
            let lamports_diff = new_minimum_balance.saturating_sub(account.lamports());
            **payer.try_borrow_mut_lamports()? -= lamports_diff;
            **account.try_borrow_mut_lamports()? += lamports_diff;
        }
        core::cmp::Ordering::Less => {
            // Return excess lamports to payer
            let lamports_diff = account.lamports().saturating_sub(new_minimum_balance);
            **account.try_borrow_mut_lamports()? -= lamports_diff;
            **payer.try_borrow_mut_lamports()? += lamports_diff;
        }
        core::cmp::Ordering::Equal => {
            // No lamport transfer needed
        }
    }

    // Reallocate the account
    account.realloc(new_size, zero_out)?;

    Ok(())
}
```

